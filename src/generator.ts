import { promises as fs } from 'fs';
import path from 'path';
import { FileScanner } from './scanner.js';
import { TemplateEngine, type TemplateContext } from './templates.js';
import type {
  BarrelDefinition,
  MarkerConfig,
  ProcessingOptions,
  VariableBarrelDefinition,
} from './types.js';

export class BarrelGenerator {
  private scanner: FileScanner;
  private templateEngine: TemplateEngine;

  constructor() {
    this.scanner = new FileScanner();
    this.templateEngine = new TemplateEngine();
  }

  async generateBarrels(definitions: BarrelDefinition[]): Promise<void> {
    for (const definition of definitions) {
      await this.generateBarrel(definition);
    }
  }

  async generateBarrel(definition: BarrelDefinition): Promise<void> {
    // Input validation
    if (!definition.name?.trim()) {
      throw new Error('Barrel definition must have a non-empty name');
    }

    if (!definition.output?.trim()) {
      throw new Error(`Barrel '${definition.name}': output path cannot be empty`);
    }

    // Generate using variable-based template format
    return this.generateVariableBasedBarrel(definition);
  }

  // Method to register custom templates
  registerTemplate(name: string, template: (context: TemplateContext) => string): void {
    this.templateEngine.registerTemplate(name, template);
  }

  private async generateVariableBasedBarrel(definition: VariableBarrelDefinition): Promise<void> {
    const startTime = Date.now();

    // Create scanner with definition options
    const mergedOptions: ProcessingOptions = {
      followSymlinks: false,
      preserveExtensions: definition.options?.preserveExtensions ?? false,
      extensions: definition.options?.extensions ?? ['.ts', '.tsx'],
      validateExports: definition.options?.validateExports ?? false,
      dryRun: definition.options?.dryRun || false,
    };

    // Generate content using the variable template
    const templateEngine = new TemplateEngine();
    const context: TemplateContext = {
      files: [], // Not used in variable template
      options: {
        namedExports: false,
        preserveExtensions: mergedOptions.preserveExtensions,
        sortExports: true,
        addBanner: true,
        customBanner: undefined,
      },
      outputPath: definition.output,
      templateConfig: definition.template,
      banner: '',
      metadata: {
        generatedAt: new Date().toISOString(),
        fileCount: 0,
      },
    };

    const content = templateEngine.generate(definition.template.name, context);

    // Write output file (unless dry run)
    if (!mergedOptions.dryRun) {
      const mode = definition.template?.mode || 'replace';

      if (mode === 'partial-replace') {
        await this.writeWithMarkers(definition.output, content, {
          startMarker: '// AUTO-GENERATED EXPORTS - START',
          endMarker: '// AUTO-GENERATED EXPORTS - END',
          preserveContent: true,
        });
      } else {
        // Use default banner since variable template doesn't support custom banner
        const banner =
          '// This file is auto-generated by @validkeys/ollypop-ts\n// Do not edit this file manually - your changes will be overwritten\n\n';
        const fullContent = banner + content;
        await this.writeBarrelFile(definition.output, fullContent);
      }

      const duration = Date.now() - startTime;
      console.log(`   ✅ Generated in ${duration}ms`);
    } else {
      console.log(`   🔍 Dry run - content would be:`);
      console.log(
        content
          .split('\n')
          .map((line) => `      ${line}`)
          .join('\n')
      );
    }
  }

  private async writeBarrelFile(outputPath: string, content: string): Promise<void> {
    const outputDir = path.dirname(outputPath);
    await fs.mkdir(outputDir, { recursive: true });
    await fs.writeFile(outputPath, content, 'utf8');
  }

  private async writeWithMarkers(
    outputPath: string,
    content: string,
    markers: MarkerConfig
  ): Promise<void> {
    try {
      // Read existing file content
      let existingContent = '';
      try {
        existingContent = await fs.readFile(outputPath, 'utf8');
      } catch {
        // File doesn't exist, that's fine
      }

      // Extract content between markers if they exist
      const startMarker = markers.startMarker || '// AUTO-GENERATED EXPORTS - START';
      const endMarker = markers.endMarker || '// AUTO-GENERATED EXPORTS - END';

      let updatedContent: string;

      const banner =
        '// This section is auto-generated by @validkeys/ollypop-ts\n// Do not edit this section manually - your changes will be overwritten\n\n';

      if (existingContent.includes(startMarker)) {
        // Replace content between markers
        const beforeMarker = existingContent.substring(0, existingContent.indexOf(startMarker));
        const afterMarkerIndex = existingContent.indexOf(endMarker);
        const afterMarker =
          afterMarkerIndex !== -1
            ? existingContent.substring(afterMarkerIndex + endMarker.length)
            : '';

        updatedContent = [
          beforeMarker.trimEnd(),
          startMarker,
          '',
          banner + content.trim(),
          '',
          endMarker,
          afterMarker.trimStart(),
        ]
          .filter((line) => line !== undefined)
          .join('\n');
      } else {
        // Create new file with markers
        updatedContent = [startMarker, '', banner + content.trim(), '', endMarker].join('\n');
      }

      // Write updated content
      await this.writeBarrelFile(outputPath, updatedContent);
    } catch (error) {
      throw new Error(`Failed to write with markers: ${error}`);
    }
  }
}
